/**
 * 
 */
package setvis.shape;

import static setvis.VecUtil.addVec;
import static setvis.VecUtil.middleVec;
import static setvis.VecUtil.mulVec;
import static setvis.VecUtil.normVec;
import static setvis.VecUtil.subVec;
import static setvis.VecUtil.vecLengthSqr;

import java.awt.Shape;
import java.awt.geom.GeneralPath;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;

import setvis.SetOutline;

/**
 * Generates a bezier interpolated {@link Shape} for the vertices generated by
 * {@link SetOutline#createOutline(Rectangle2D[], Rectangle2D[])}.
 * 
 * @author Joschi <josua.krause@googlemail.com>
 * 
 */
public class BezierShapeGenerator extends RoundShapeGenerator {

	/**
	 * Indicates that there should be a maximal radius for the curves.
	 */
	private final boolean hasMaxRadius;

	/**
	 * Creates an {@link BezierShapeGenerator} with a given set outline creator.
	 * 
	 * @param outline
	 *            The creator of the set outlines.
	 * @param clockwise
	 *            Whether the result of the set outlines are interpreted in
	 *            clockwise order.
	 * @param hasMaxRadius
	 *            Whether there should be a maximal radius for the curves.
	 */
	public BezierShapeGenerator(final SetOutline outline,
			final boolean clockwise, final boolean hasMaxRadius) {
		super(outline, clockwise);
		this.hasMaxRadius = hasMaxRadius;
	}

	@Override
	protected Shape convertToShape(final Point2D[] points) {
		final GeneralPath res = new GeneralPath();
		final int len = points.length;
		Point2D first = null;
		for (int i = 0; i < len; ++i) {
			final Point2D[] vertices = hasMaxRadius ? getRestrictedBezier(
					points, i) : getBezierForPoint(points, i);
			final Point2D p = vertices[0];
			if (first == null) {
				res.moveTo(p.getX(), p.getY());
				first = p;
			} else if (hasMaxRadius) {
				res.lineTo(p.getX(), p.getY());
			}
			final Point2D s0 = vertices[1];
			final Point2D s1 = vertices[2];
			res.curveTo(s0.getX(), s0.getY(), s0.getX(), s0.getY(), s1.getX(),
					s1.getY());
		}
		if (first != null && hasMaxRadius) {
			res.lineTo(first.getX(), first.getY());
		}
		return res;
	}

	/**
	 * Creates bezier points by using the middle points of two points of the
	 * outline as reference points.
	 * 
	 * @param points
	 *            The array containing the outline.
	 * @param index
	 *            The current index in the outline.
	 * @return The bezier reference points.
	 */
	private Point2D[] getBezierForPoint(final Point2D[] points, final int index) {
		final int len = points.length;
		final Point2D point = points[index];
		final Point2D left = points[getOtherIndex(index, len, false)];
		final Point2D right = points[getOtherIndex(index, len, true)];
		return new Point2D[] { middleVec(point, left), point,
				middleVec(point, right) };
	}

	/**
	 * Creates bezier points by going a certain radius away from the current
	 * point in the directions of the neighbors.
	 * 
	 * @param points
	 *            The array containing the outline.
	 * @param index
	 *            The index of the current point.
	 * @return The bezier reference points.
	 */
	private Point2D[] getRestrictedBezier(final Point2D[] points,
			final int index) {
		// even with four times the radius the curve won't cut the original
		// vertices
		final double rad = getRadius() * 4.0;
		final double qrad = rad * rad;
		final int len = points.length;
		final Point2D point = points[index];
		final Point2D left = points[getOtherIndex(index, len, false)];
		final Point2D right = points[getOtherIndex(index, len, true)];
		Point2D lp = middleVec(point, left);
		final Point2D dlp = subVec(lp, point);
		if (vecLengthSqr(dlp) > qrad) {
			lp = addVec(mulVec(normVec(dlp), rad), point);
		}
		Point2D rp = middleVec(point, right);
		final Point2D drp = subVec(rp, point);
		if (vecLengthSqr(drp) > qrad) {
			rp = addVec(mulVec(normVec(drp), rad), point);
		}
		return new Point2D[] { lp, point, rp };
	}

}
